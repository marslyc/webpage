import{b as ut,B as X,L as pt,Y as mt,c as h,a0 as ft,al as j,am as tt,an as Z,ao as yt,ap as xt,S as wt,a as bt,aq as gt,r as St,ar as zt,q as Mt,W as vt,as as Tt,s as _t,at as Pt,au as Bt,M as At,l as Lt}from"./three.module-BUZdne6h.js";import{S as Et}from"./stats.module--VATS4Kh.js";import{G as Vt}from"./GLTFLoader-DwfIB8W0.js";import{g as Ct}from"./lil-gui.module.min-Bc0DeA9g.js";import{_ as kt,r as It,o as Wt,c as Rt,a as qt}from"./index-E0VyOJT8.js";class Gt extends ut{constructor(t,s=16776960){super(new X,new pt({color:s,toneMapped:!1})),this.octree=t,this.color=s,this.type="OctreeHelper",this.update()}update(){const t=[];function s(o){for(let i=0;i<o.length;i++){const e=o[i].box.min,n=o[i].box.max;t.push(n.x,n.y,n.z),t.push(e.x,n.y,n.z),t.push(e.x,n.y,n.z),t.push(e.x,e.y,n.z),t.push(e.x,e.y,n.z),t.push(n.x,e.y,n.z),t.push(n.x,e.y,n.z),t.push(n.x,n.y,n.z),t.push(n.x,n.y,e.z),t.push(e.x,n.y,e.z),t.push(e.x,n.y,e.z),t.push(e.x,e.y,e.z),t.push(e.x,e.y,e.z),t.push(n.x,e.y,e.z),t.push(n.x,e.y,e.z),t.push(n.x,n.y,e.z),t.push(n.x,n.y,n.z),t.push(n.x,n.y,e.z),t.push(e.x,n.y,n.z),t.push(e.x,n.y,e.z),t.push(e.x,e.y,n.z),t.push(e.x,e.y,e.z),t.push(n.x,e.y,n.z),t.push(n.x,e.y,e.z),s(o[i].subTrees)}}s(this.octree.subTrees),this.geometry.dispose(),this.geometry=new X,this.geometry.setAttribute("position",new mt(t,3))}dispose(){this.geometry.dispose(),this.material.dispose()}}class q{constructor(t=new h(0,0,0),s=new h(0,1,0),o=1){this.start=t,this.end=s,this.radius=o}clone(){return new q(this.start.clone(),this.end.clone(),this.radius)}set(t,s,o){this.start.copy(t),this.end.copy(s),this.radius=o}copy(t){this.start.copy(t.start),this.end.copy(t.end),this.radius=t.radius}getCenter(t){return t.copy(this.end).add(this.start).multiplyScalar(.5)}translate(t){this.start.add(t),this.end.add(t)}checkAABBAxis(t,s,o,i,e,n,c,l,d){return(e-t<d||e-o<d)&&(t-n<d||o-n<d)&&(c-s<d||c-i<d)&&(s-l<d||i-l<d)}intersectsBox(t){return this.checkAABBAxis(this.start.x,this.start.y,this.end.x,this.end.y,t.min.x,t.max.x,t.min.y,t.max.y,this.radius)&&this.checkAABBAxis(this.start.x,this.start.z,this.end.x,this.end.z,t.min.x,t.max.x,t.min.z,t.max.z,this.radius)&&this.checkAABBAxis(this.start.y,this.start.z,this.end.y,this.end.z,t.min.y,t.max.y,t.min.z,t.max.z,this.radius)}}const E=new h,V=new h,W=new h,C=new h,S=new ft,D=new j,Dt=new j,R=new tt,k=new q,Ht=new h,Ot=new h,Ft=new h,Kt=1e-10;function Nt(_,t,s=null,o=null){const i=Ht.copy(_.end).sub(_.start),e=Ot.copy(t.end).sub(t.start),n=Ft.copy(t.start).sub(_.start),c=i.dot(e),l=i.dot(i),d=e.dot(e),w=e.dot(n),x=i.dot(n);let b,g;const p=l*d-c*c;if(Math.abs(p)<Kt){const m=-w/d,y=(c-w)/d;Math.abs(m-.5)<Math.abs(y-.5)?(b=0,g=m):(b=1,g=y)}else b=(w*c+x*d)/p,g=(b*c-w)/d;g=Math.max(0,Math.min(1,g)),b=Math.max(0,Math.min(1,b)),s&&s.copy(i).multiplyScalar(b).add(_.start),o&&o.copy(e).multiplyScalar(g).add(t.start)}class H{constructor(t){this.box=t,this.bounds=new Z,this.subTrees=[],this.triangles=[],this.layers=new yt}addTriangle(t){return this.bounds.min.x=Math.min(this.bounds.min.x,t.a.x,t.b.x,t.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,t.a.y,t.b.y,t.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,t.a.z,t.b.z,t.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,t.a.x,t.b.x,t.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,t.a.y,t.b.y,t.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,t.a.z,t.b.z,t.c.z),this.triangles.push(t),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(t){if(!this.box)return;const s=[],o=V.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let c=0;c<2;c++){const l=new Z,d=E.set(e,n,c);l.min.copy(this.box.min).add(d.multiply(o)),l.max.copy(l.min).add(o),s.push(new H(l))}let i;for(;i=this.triangles.pop();)for(let e=0;e<s.length;e++)s[e].box.intersectsTriangle(i)&&s[e].triangles.push(i);for(let e=0;e<s.length;e++){const n=s[e].triangles.length;n>8&&t<16&&s[e].split(t+1),n!==0&&this.subTrees.push(s[e])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(t,s){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let e=0;e<i.triangles.length;e++)s.indexOf(i.triangles[e])===-1&&s.push(i.triangles[e]);else i.getRayTriangles(t,s)}return s}triangleCapsuleIntersect(t,s){s.getPlane(S);const o=S.distanceToPoint(t.start)-t.radius,i=S.distanceToPoint(t.end)-t.radius;if(o>0&&i>0||o<-t.radius&&i<-t.radius)return!1;const e=Math.abs(o/(Math.abs(o)+Math.abs(i))),n=E.copy(t.start).lerp(t.end,e);if(s.containsPoint(n))return{normal:S.normal.clone(),point:n.clone(),depth:Math.abs(Math.min(o,i))};const c=t.radius*t.radius,l=D.set(t.start,t.end),d=[[s.a,s.b],[s.b,s.c],[s.c,s.a]];for(let w=0;w<d.length;w++){const x=Dt.set(d[w][0],d[w][1]);if(Nt(l,x,W,C),W.distanceToSquared(C)<c)return{normal:W.clone().sub(C).normalize(),point:C.clone(),depth:t.radius-W.distanceTo(C)}}return!1}triangleSphereIntersect(t,s){if(s.getPlane(S),!t.intersectsPlane(S))return!1;const o=Math.abs(S.distanceToSphere(t)),i=t.radius*t.radius-o*o,e=S.projectPoint(t.center,E);if(s.containsPoint(t.center))return{normal:S.normal.clone(),point:e.clone(),depth:Math.abs(S.distanceToSphere(t))};const n=[[s.a,s.b],[s.b,s.c],[s.c,s.a]];for(let c=0;c<n.length;c++){D.set(n[c][0],n[c][1]),D.closestPointToPoint(e,!0,V);const l=V.distanceToSquared(t.center);if(l<i)return{normal:t.center.clone().sub(V).normalize(),point:V.clone(),depth:t.radius-Math.sqrt(l)}}return!1}getSphereTriangles(t,s){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let e=0;e<i.triangles.length;e++)s.indexOf(i.triangles[e])===-1&&s.push(i.triangles[e]);else i.getSphereTriangles(t,s)}}getCapsuleTriangles(t,s){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let e=0;e<i.triangles.length;e++)s.indexOf(i.triangles[e])===-1&&s.push(i.triangles[e]);else i.getCapsuleTriangles(t,s)}}sphereIntersect(t){R.copy(t);const s=[];let o,i=!1;this.getSphereTriangles(t,s);for(let e=0;e<s.length;e++)(o=this.triangleSphereIntersect(R,s[e]))&&(i=!0,R.center.add(o.normal.multiplyScalar(o.depth)));if(i){const e=R.center.clone().sub(t.center),n=e.length();return{normal:e.normalize(),depth:n}}return!1}capsuleIntersect(t){k.copy(t);const s=[];let o,i=!1;this.getCapsuleTriangles(k,s);for(let e=0;e<s.length;e++)(o=this.triangleCapsuleIntersect(k,s[e]))&&(i=!0,k.translate(o.normal.multiplyScalar(o.depth)));if(i){const e=k.getCenter(new h).sub(t.getCenter(E)),n=e.length();return{normal:e.normalize(),depth:n}}return!1}rayIntersect(t){if(t.direction.length()===0)return;const s=[];let o,i,e=1e100;this.getRayTriangles(t,s);for(let n=0;n<s.length;n++){const c=t.intersectTriangle(s[n].a,s[n].b,s[n].c,!0,E);if(c){const l=c.sub(t.origin).length();e>l&&(i=c.clone().add(t.origin),e=l,o=s[n])}}return e<1e100?{distance:e,triangle:o,position:i}:!1}fromGraphNode(t){return t.updateWorldMatrix(!0,!0),t.traverse(s=>{if(s.isMesh===!0&&this.layers.test(s.layers)){let o,i=!1;s.geometry.index!==null?(i=!0,o=s.geometry.toNonIndexed()):o=s.geometry;const e=o.getAttribute("position");for(let n=0;n<e.count;n+=3){const c=new h().fromBufferAttribute(e,n),l=new h().fromBufferAttribute(e,n+1),d=new h().fromBufferAttribute(e,n+2);c.applyMatrix4(s.matrixWorld),l.applyMatrix4(s.matrixWorld),d.applyMatrix4(s.matrixWorld),this.addTriangle(new xt(c,l,d))}i&&o.dispose()}}),this.build(),this}clear(){return this.box=null,this.bounds.makeEmpty(),this.subTrees.length=0,this.triangles.length=0,this}}const J=30,Yt=100,Q=.2,$=5,Ut={__name:"Game",setup(_){const t=new Lt,s=new wt;s.background=new bt(8965358),s.fog=new gt(8965358,0,50);const o=new St(70,window.innerWidth/window.innerHeight,.1,1e3);o.rotation.order="YXZ";const i=new zt(9290206,26253,1.5);i.position.set(2,1,1),s.add(i);const e=new Mt(16777215,2.5);e.position.set(-5,25,-1),e.castShadow=!0,e.shadow.camera.near=.01,e.shadow.camera.far=500,e.shadow.camera.right=30,e.shadow.camera.left=-30,e.shadow.camera.top=30,e.shadow.camera.bottom=-30,e.shadow.mapSize.width=1024,e.shadow.mapSize.height=1024,e.shadow.radius=4,e.shadow.bias=-6e-5,s.add(e);const n=It(null),c=new vt({antialias:!0});c.setPixelRatio(window.devicePixelRatio),c.setSize(window.innerWidth,window.innerHeight),c.setAnimationLoop(ht),c.shadowMap.enabled=!0,c.shadowMap.type=Tt,c.toneMapping=_t;const l=new Et;l.domElement.style.position="absolute",l.domElement.style.top="0px";const d=new Pt(Q,5),w=new Bt({color:14605965}),x=[];let b=0;for(let r=0;r<Yt;r++){const a=new At(d,w);a.castShadow=!0,a.receiveShadow=!0,s.add(a),x.push({mesh:a,collider:new tt(new h(0,-100,0),Q),velocity:new h})}const g=new H,p=new q(new h(0,.35,0),new h(0,1,0),.35),m=new h,y=new h;let P=!1,O=0;const v={},G=new h,F=new h,K=new h;Wt(()=>{n.value.appendChild(c.domElement),n.value.appendChild(l.domElement),document.addEventListener("keydown",r=>{v[r.code]=!0}),document.addEventListener("keyup",r=>{v[r.code]=!1}),n.value.addEventListener("mousedown",()=>{document.body.requestPointerLock(),O=performance.now()}),document.addEventListener("mouseup",()=>{document.pointerLockElement!==null&&st()}),document.body.addEventListener("mousemove",r=>{document.pointerLockElement===document.body&&(o.rotation.y-=r.movementX/500,o.rotation.x-=r.movementY/500)}),window.addEventListener("resize",et)});function et(){o.aspect=window.innerWidth/window.innerHeight,o.updateProjectionMatrix(),c.setSize(window.innerWidth,window.innerHeight)}function st(){const r=x[b];o.getWorldDirection(y),r.collider.center.copy(p.end).addScaledVector(y,p.radius*1.5);const a=15+30*(1-Math.exp((O-performance.now())*.001));r.velocity.copy(y).multiplyScalar(a),r.velocity.addScaledVector(m,2),b=(b+1)%x.length}function nt(){const r=g.capsuleIntersect(p);P=!1,r&&(P=r.normal.y>0,P||m.addScaledVector(r.normal,-r.normal.dot(m)),r.depth>=1e-10&&p.translate(r.normal.multiplyScalar(r.depth)))}function ot(r){let a=Math.exp(-4*r)-1;P||(m.y-=J*r,a*=.1),m.addScaledVector(m,a);const u=m.clone().multiplyScalar(r);p.translate(u),nt(),o.position.copy(p.end)}function it(r){const a=G.addVectors(p.start,p.end).multiplyScalar(.5),u=r.collider.center,f=p.radius+r.collider.radius,M=f*f;for(const A of[p.start,p.end,a]){const B=A.distanceToSquared(u);if(B<M){const T=G.subVectors(A,u).normalize(),z=F.copy(T).multiplyScalar(T.dot(m)),L=K.copy(T).multiplyScalar(T.dot(r.velocity));m.add(L).sub(z),r.velocity.add(z).sub(L);const I=(f-Math.sqrt(B))/2;u.addScaledVector(T,-I)}}}function rt(){for(let r=0,a=x.length;r<a;r++){const u=x[r];for(let f=r+1;f<a;f++){const M=x[f],A=u.collider.center.distanceToSquared(M.collider.center),B=u.collider.radius+M.collider.radius,T=B*B;if(A<T){const z=G.subVectors(u.collider.center,M.collider.center).normalize(),L=F.copy(z).multiplyScalar(z.dot(u.velocity)),I=K.copy(z).multiplyScalar(z.dot(M.velocity));u.velocity.add(I).sub(L),M.velocity.add(L).sub(I);const U=(B-Math.sqrt(A))/2;u.collider.center.addScaledVector(z,U),M.collider.center.addScaledVector(z,-U)}}}}function at(r){x.forEach(a=>{a.collider.center.addScaledVector(a.velocity,r);const u=g.sphereIntersect(a.collider);u?(a.velocity.addScaledVector(u.normal,-u.normal.dot(a.velocity)*1.5),a.collider.center.add(u.normal.multiplyScalar(u.depth))):a.velocity.y-=J*r;const f=Math.exp(-1.5*r)-1;a.velocity.addScaledVector(a.velocity,f),it(a)}),rt();for(const a of x)a.mesh.position.copy(a.collider.center)}function N(){return o.getWorldDirection(y),y.y=0,y.normalize(),y}function Y(){return o.getWorldDirection(y),y.y=0,y.normalize(),y.cross(o.up),y}function ct(r){const a=r*(P?25:8);v.KeyW&&m.add(N().multiplyScalar(a)),v.KeyS&&m.add(N().multiplyScalar(-a)),v.KeyA&&m.add(Y().multiplyScalar(-a)),v.KeyD&&m.add(Y().multiplyScalar(a)),P&&v.Space&&(m.y=15)}let lt=new URL("/assets/collision-world-DniMB0qq.glb",import.meta.url).href;new Vt().load(lt,r=>{s.add(r.scene),g.fromGraphNode(r.scene),r.scene.traverse(f=>{f.isMesh&&(f.castShadow=!0,f.receiveShadow=!0,f.material.map&&(f.material.map.anisotropy=4))});const a=new Gt(g);a.visible=!1,s.add(a),new Ct({width:200}).add({debug:!1},"debug").onChange(function(f){a.visible=f})});function dt(){o.position.y<=-25&&(p.start.set(0,.35,0),p.end.set(0,1,0),p.radius=.35,o.position.copy(p.end),o.rotation.set(0,0,0))}function ht(){const r=Math.min(.05,t.getDelta())/$;for(let a=0;a<$;a++)ct(r),ot(r),at(r),dt();c.render(s,o),l.update()}return(r,a)=>(qt(),Rt("div",{id:"box1",ref_key:"gameScene",ref:n},null,512))}},te=kt(Ut,[["__scopeId","data-v-57ce199f"]]);export{te as default};
